// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bitcoin/commands.proto

#ifndef PROTOBUF_INCLUDED_bitcoin_2fcommands_2eproto
#define PROTOBUF_INCLUDED_bitcoin_2fcommands_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "bitcoin/account.pb.h"
#include "bitcoin/operation.pb.h"
#include "common/amount.pb.h"
#include "common/block.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bitcoin_2fcommands_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_bitcoin_2fcommands_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_bitcoin_2fcommands_2eproto();
namespace ledger {
namespace core {
namespace message {
namespace bitcoin {
class BitcoinRequest;
class BitcoinRequestDefaultTypeInternal;
extern BitcoinRequestDefaultTypeInternal _BitcoinRequest_default_instance_;
class GetBalanceRequest;
class GetBalanceRequestDefaultTypeInternal;
extern GetBalanceRequestDefaultTypeInternal _GetBalanceRequest_default_instance_;
class GetBalanceResponse;
class GetBalanceResponseDefaultTypeInternal;
extern GetBalanceResponseDefaultTypeInternal _GetBalanceResponse_default_instance_;
class GetFreshAddressRequest;
class GetFreshAddressRequestDefaultTypeInternal;
extern GetFreshAddressRequestDefaultTypeInternal _GetFreshAddressRequest_default_instance_;
class GetFreshAddressResponse;
class GetFreshAddressResponseDefaultTypeInternal;
extern GetFreshAddressResponseDefaultTypeInternal _GetFreshAddressResponse_default_instance_;
class GetLastBlockRequest;
class GetLastBlockRequestDefaultTypeInternal;
extern GetLastBlockRequestDefaultTypeInternal _GetLastBlockRequest_default_instance_;
class GetLastBlockResponse;
class GetLastBlockResponseDefaultTypeInternal;
extern GetLastBlockResponseDefaultTypeInternal _GetLastBlockResponse_default_instance_;
class GetOperationsRequest;
class GetOperationsRequestDefaultTypeInternal;
extern GetOperationsRequestDefaultTypeInternal _GetOperationsRequest_default_instance_;
class GetOperationsResponse;
class GetOperationsResponseDefaultTypeInternal;
extern GetOperationsResponseDefaultTypeInternal _GetOperationsResponse_default_instance_;
class LedgerExplorerConfig;
class LedgerExplorerConfigDefaultTypeInternal;
extern LedgerExplorerConfigDefaultTypeInternal _LedgerExplorerConfig_default_instance_;
class SyncAccountRequest;
class SyncAccountRequestDefaultTypeInternal;
extern SyncAccountRequestDefaultTypeInternal _SyncAccountRequest_default_instance_;
class SyncAccountResponse;
class SyncAccountResponseDefaultTypeInternal;
extern SyncAccountResponseDefaultTypeInternal _SyncAccountResponse_default_instance_;
}  // namespace bitcoin
}  // namespace message
}  // namespace core
}  // namespace ledger
namespace google {
namespace protobuf {
template<> ::ledger::core::message::bitcoin::BitcoinRequest* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::BitcoinRequest>(Arena*);
template<> ::ledger::core::message::bitcoin::GetBalanceRequest* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetBalanceRequest>(Arena*);
template<> ::ledger::core::message::bitcoin::GetBalanceResponse* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetBalanceResponse>(Arena*);
template<> ::ledger::core::message::bitcoin::GetFreshAddressRequest* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetFreshAddressRequest>(Arena*);
template<> ::ledger::core::message::bitcoin::GetFreshAddressResponse* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetFreshAddressResponse>(Arena*);
template<> ::ledger::core::message::bitcoin::GetLastBlockRequest* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetLastBlockRequest>(Arena*);
template<> ::ledger::core::message::bitcoin::GetLastBlockResponse* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetLastBlockResponse>(Arena*);
template<> ::ledger::core::message::bitcoin::GetOperationsRequest* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetOperationsRequest>(Arena*);
template<> ::ledger::core::message::bitcoin::GetOperationsResponse* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetOperationsResponse>(Arena*);
template<> ::ledger::core::message::bitcoin::LedgerExplorerConfig* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::LedgerExplorerConfig>(Arena*);
template<> ::ledger::core::message::bitcoin::SyncAccountRequest* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::SyncAccountRequest>(Arena*);
template<> ::ledger::core::message::bitcoin::SyncAccountResponse* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::SyncAccountResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ledger {
namespace core {
namespace message {
namespace bitcoin {

// ===================================================================

class LedgerExplorerConfig :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.LedgerExplorerConfig) */ {
 public:
  LedgerExplorerConfig();
  virtual ~LedgerExplorerConfig();

  LedgerExplorerConfig(const LedgerExplorerConfig& from);

  inline LedgerExplorerConfig& operator=(const LedgerExplorerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LedgerExplorerConfig(LedgerExplorerConfig&& from) noexcept
    : LedgerExplorerConfig() {
    *this = ::std::move(from);
  }

  inline LedgerExplorerConfig& operator=(LedgerExplorerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LedgerExplorerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LedgerExplorerConfig* internal_default_instance() {
    return reinterpret_cast<const LedgerExplorerConfig*>(
               &_LedgerExplorerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LedgerExplorerConfig* other);
  friend void swap(LedgerExplorerConfig& a, LedgerExplorerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LedgerExplorerConfig* New() const final {
    return CreateMaybeMessage<LedgerExplorerConfig>(nullptr);
  }

  LedgerExplorerConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LedgerExplorerConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LedgerExplorerConfig& from);
  void MergeFrom(const LedgerExplorerConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LedgerExplorerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string endpoint = 2;
  void clear_endpoint();
  static const int kEndpointFieldNumber = 2;
  const ::std::string& endpoint() const;
  void set_endpoint(const ::std::string& value);
  #if LANG_CXX11
  void set_endpoint(::std::string&& value);
  #endif
  void set_endpoint(const char* value);
  void set_endpoint(const char* value, size_t size);
  ::std::string* mutable_endpoint();
  ::std::string* release_endpoint();
  void set_allocated_endpoint(::std::string* endpoint);

  // uint32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // uint32 port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.LedgerExplorerConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr endpoint_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class SyncAccountRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.SyncAccountRequest) */ {
 public:
  SyncAccountRequest();
  virtual ~SyncAccountRequest();

  SyncAccountRequest(const SyncAccountRequest& from);

  inline SyncAccountRequest& operator=(const SyncAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SyncAccountRequest(SyncAccountRequest&& from) noexcept
    : SyncAccountRequest() {
    *this = ::std::move(from);
  }

  inline SyncAccountRequest& operator=(SyncAccountRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SyncAccountRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SyncAccountRequest* internal_default_instance() {
    return reinterpret_cast<const SyncAccountRequest*>(
               &_SyncAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SyncAccountRequest* other);
  friend void swap(SyncAccountRequest& a, SyncAccountRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SyncAccountRequest* New() const final {
    return CreateMaybeMessage<SyncAccountRequest>(nullptr);
  }

  SyncAccountRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SyncAccountRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SyncAccountRequest& from);
  void MergeFrom(const SyncAccountRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncAccountRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.core.message.bitcoin.AccountID account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::ledger::core::message::bitcoin::AccountID& account_id() const;
  ::ledger::core::message::bitcoin::AccountID* release_account_id();
  ::ledger::core::message::bitcoin::AccountID* mutable_account_id();
  void set_allocated_account_id(::ledger::core::message::bitcoin::AccountID* account_id);

  // .ledger.core.message.bitcoin.LedgerExplorerConfig explorer = 2;
  bool has_explorer() const;
  void clear_explorer();
  static const int kExplorerFieldNumber = 2;
  const ::ledger::core::message::bitcoin::LedgerExplorerConfig& explorer() const;
  ::ledger::core::message::bitcoin::LedgerExplorerConfig* release_explorer();
  ::ledger::core::message::bitcoin::LedgerExplorerConfig* mutable_explorer();
  void set_allocated_explorer(::ledger::core::message::bitcoin::LedgerExplorerConfig* explorer);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.SyncAccountRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ledger::core::message::bitcoin::AccountID* account_id_;
  ::ledger::core::message::bitcoin::LedgerExplorerConfig* explorer_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class SyncAccountResponse :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.SyncAccountResponse) */ {
 public:
  SyncAccountResponse();
  virtual ~SyncAccountResponse();

  SyncAccountResponse(const SyncAccountResponse& from);

  inline SyncAccountResponse& operator=(const SyncAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SyncAccountResponse(SyncAccountResponse&& from) noexcept
    : SyncAccountResponse() {
    *this = ::std::move(from);
  }

  inline SyncAccountResponse& operator=(SyncAccountResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SyncAccountResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SyncAccountResponse* internal_default_instance() {
    return reinterpret_cast<const SyncAccountResponse*>(
               &_SyncAccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SyncAccountResponse* other);
  friend void swap(SyncAccountResponse& a, SyncAccountResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SyncAccountResponse* New() const final {
    return CreateMaybeMessage<SyncAccountResponse>(nullptr);
  }

  SyncAccountResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SyncAccountResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SyncAccountResponse& from);
  void MergeFrom(const SyncAccountResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncAccountResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool new_acc = 1;
  void clear_new_acc();
  static const int kNewAccFieldNumber = 1;
  bool new_acc() const;
  void set_new_acc(bool value);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.SyncAccountResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool new_acc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GetBalanceRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetBalanceRequest) */ {
 public:
  GetBalanceRequest();
  virtual ~GetBalanceRequest();

  GetBalanceRequest(const GetBalanceRequest& from);

  inline GetBalanceRequest& operator=(const GetBalanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBalanceRequest(GetBalanceRequest&& from) noexcept
    : GetBalanceRequest() {
    *this = ::std::move(from);
  }

  inline GetBalanceRequest& operator=(GetBalanceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetBalanceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBalanceRequest* internal_default_instance() {
    return reinterpret_cast<const GetBalanceRequest*>(
               &_GetBalanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GetBalanceRequest* other);
  friend void swap(GetBalanceRequest& a, GetBalanceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBalanceRequest* New() const final {
    return CreateMaybeMessage<GetBalanceRequest>(nullptr);
  }

  GetBalanceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBalanceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBalanceRequest& from);
  void MergeFrom(const GetBalanceRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBalanceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.core.message.bitcoin.AccountID account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::ledger::core::message::bitcoin::AccountID& account_id() const;
  ::ledger::core::message::bitcoin::AccountID* release_account_id();
  ::ledger::core::message::bitcoin::AccountID* mutable_account_id();
  void set_allocated_account_id(::ledger::core::message::bitcoin::AccountID* account_id);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetBalanceRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ledger::core::message::bitcoin::AccountID* account_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GetBalanceResponse :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetBalanceResponse) */ {
 public:
  GetBalanceResponse();
  virtual ~GetBalanceResponse();

  GetBalanceResponse(const GetBalanceResponse& from);

  inline GetBalanceResponse& operator=(const GetBalanceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBalanceResponse(GetBalanceResponse&& from) noexcept
    : GetBalanceResponse() {
    *this = ::std::move(from);
  }

  inline GetBalanceResponse& operator=(GetBalanceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetBalanceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBalanceResponse* internal_default_instance() {
    return reinterpret_cast<const GetBalanceResponse*>(
               &_GetBalanceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GetBalanceResponse* other);
  friend void swap(GetBalanceResponse& a, GetBalanceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBalanceResponse* New() const final {
    return CreateMaybeMessage<GetBalanceResponse>(nullptr);
  }

  GetBalanceResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBalanceResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBalanceResponse& from);
  void MergeFrom(const GetBalanceResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBalanceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.core.message.common.Amount amount = 1;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  const ::ledger::core::message::common::Amount& amount() const;
  ::ledger::core::message::common::Amount* release_amount();
  ::ledger::core::message::common::Amount* mutable_amount();
  void set_allocated_amount(::ledger::core::message::common::Amount* amount);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetBalanceResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ledger::core::message::common::Amount* amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GetOperationsRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetOperationsRequest) */ {
 public:
  GetOperationsRequest();
  virtual ~GetOperationsRequest();

  GetOperationsRequest(const GetOperationsRequest& from);

  inline GetOperationsRequest& operator=(const GetOperationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetOperationsRequest(GetOperationsRequest&& from) noexcept
    : GetOperationsRequest() {
    *this = ::std::move(from);
  }

  inline GetOperationsRequest& operator=(GetOperationsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetOperationsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetOperationsRequest* internal_default_instance() {
    return reinterpret_cast<const GetOperationsRequest*>(
               &_GetOperationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GetOperationsRequest* other);
  friend void swap(GetOperationsRequest& a, GetOperationsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetOperationsRequest* New() const final {
    return CreateMaybeMessage<GetOperationsRequest>(nullptr);
  }

  GetOperationsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetOperationsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetOperationsRequest& from);
  void MergeFrom(const GetOperationsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOperationsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.core.message.bitcoin.AccountID account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::ledger::core::message::bitcoin::AccountID& account_id() const;
  ::ledger::core::message::bitcoin::AccountID* release_account_id();
  ::ledger::core::message::bitcoin::AccountID* mutable_account_id();
  void set_allocated_account_id(::ledger::core::message::bitcoin::AccountID* account_id);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetOperationsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ledger::core::message::bitcoin::AccountID* account_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GetOperationsResponse :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetOperationsResponse) */ {
 public:
  GetOperationsResponse();
  virtual ~GetOperationsResponse();

  GetOperationsResponse(const GetOperationsResponse& from);

  inline GetOperationsResponse& operator=(const GetOperationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetOperationsResponse(GetOperationsResponse&& from) noexcept
    : GetOperationsResponse() {
    *this = ::std::move(from);
  }

  inline GetOperationsResponse& operator=(GetOperationsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetOperationsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetOperationsResponse* internal_default_instance() {
    return reinterpret_cast<const GetOperationsResponse*>(
               &_GetOperationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GetOperationsResponse* other);
  friend void swap(GetOperationsResponse& a, GetOperationsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetOperationsResponse* New() const final {
    return CreateMaybeMessage<GetOperationsResponse>(nullptr);
  }

  GetOperationsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetOperationsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetOperationsResponse& from);
  void MergeFrom(const GetOperationsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOperationsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ledger.core.message.bitcoin.Operation operations = 1;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 1;
  ::ledger::core::message::bitcoin::Operation* mutable_operations(int index);
  ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Operation >*
      mutable_operations();
  const ::ledger::core::message::bitcoin::Operation& operations(int index) const;
  ::ledger::core::message::bitcoin::Operation* add_operations();
  const ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Operation >&
      operations() const;

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetOperationsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Operation > operations_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GetLastBlockRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetLastBlockRequest) */ {
 public:
  GetLastBlockRequest();
  virtual ~GetLastBlockRequest();

  GetLastBlockRequest(const GetLastBlockRequest& from);

  inline GetLastBlockRequest& operator=(const GetLastBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetLastBlockRequest(GetLastBlockRequest&& from) noexcept
    : GetLastBlockRequest() {
    *this = ::std::move(from);
  }

  inline GetLastBlockRequest& operator=(GetLastBlockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetLastBlockRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetLastBlockRequest* internal_default_instance() {
    return reinterpret_cast<const GetLastBlockRequest*>(
               &_GetLastBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(GetLastBlockRequest* other);
  friend void swap(GetLastBlockRequest& a, GetLastBlockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetLastBlockRequest* New() const final {
    return CreateMaybeMessage<GetLastBlockRequest>(nullptr);
  }

  GetLastBlockRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetLastBlockRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetLastBlockRequest& from);
  void MergeFrom(const GetLastBlockRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLastBlockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.core.message.bitcoin.AccountID account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::ledger::core::message::bitcoin::AccountID& account_id() const;
  ::ledger::core::message::bitcoin::AccountID* release_account_id();
  ::ledger::core::message::bitcoin::AccountID* mutable_account_id();
  void set_allocated_account_id(::ledger::core::message::bitcoin::AccountID* account_id);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetLastBlockRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ledger::core::message::bitcoin::AccountID* account_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GetLastBlockResponse :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetLastBlockResponse) */ {
 public:
  GetLastBlockResponse();
  virtual ~GetLastBlockResponse();

  GetLastBlockResponse(const GetLastBlockResponse& from);

  inline GetLastBlockResponse& operator=(const GetLastBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetLastBlockResponse(GetLastBlockResponse&& from) noexcept
    : GetLastBlockResponse() {
    *this = ::std::move(from);
  }

  inline GetLastBlockResponse& operator=(GetLastBlockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetLastBlockResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetLastBlockResponse* internal_default_instance() {
    return reinterpret_cast<const GetLastBlockResponse*>(
               &_GetLastBlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GetLastBlockResponse* other);
  friend void swap(GetLastBlockResponse& a, GetLastBlockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetLastBlockResponse* New() const final {
    return CreateMaybeMessage<GetLastBlockResponse>(nullptr);
  }

  GetLastBlockResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetLastBlockResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetLastBlockResponse& from);
  void MergeFrom(const GetLastBlockResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLastBlockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.core.message.common.Block last_block = 1;
  bool has_last_block() const;
  void clear_last_block();
  static const int kLastBlockFieldNumber = 1;
  const ::ledger::core::message::common::Block& last_block() const;
  ::ledger::core::message::common::Block* release_last_block();
  ::ledger::core::message::common::Block* mutable_last_block();
  void set_allocated_last_block(::ledger::core::message::common::Block* last_block);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetLastBlockResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ledger::core::message::common::Block* last_block_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GetFreshAddressRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetFreshAddressRequest) */ {
 public:
  GetFreshAddressRequest();
  virtual ~GetFreshAddressRequest();

  GetFreshAddressRequest(const GetFreshAddressRequest& from);

  inline GetFreshAddressRequest& operator=(const GetFreshAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetFreshAddressRequest(GetFreshAddressRequest&& from) noexcept
    : GetFreshAddressRequest() {
    *this = ::std::move(from);
  }

  inline GetFreshAddressRequest& operator=(GetFreshAddressRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetFreshAddressRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetFreshAddressRequest* internal_default_instance() {
    return reinterpret_cast<const GetFreshAddressRequest*>(
               &_GetFreshAddressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetFreshAddressRequest* other);
  friend void swap(GetFreshAddressRequest& a, GetFreshAddressRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetFreshAddressRequest* New() const final {
    return CreateMaybeMessage<GetFreshAddressRequest>(nullptr);
  }

  GetFreshAddressRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetFreshAddressRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetFreshAddressRequest& from);
  void MergeFrom(const GetFreshAddressRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFreshAddressRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.core.message.bitcoin.AccountID account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::ledger::core::message::bitcoin::AccountID& account_id() const;
  ::ledger::core::message::bitcoin::AccountID* release_account_id();
  ::ledger::core::message::bitcoin::AccountID* mutable_account_id();
  void set_allocated_account_id(::ledger::core::message::bitcoin::AccountID* account_id);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetFreshAddressRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ledger::core::message::bitcoin::AccountID* account_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GetFreshAddressResponse :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetFreshAddressResponse) */ {
 public:
  GetFreshAddressResponse();
  virtual ~GetFreshAddressResponse();

  GetFreshAddressResponse(const GetFreshAddressResponse& from);

  inline GetFreshAddressResponse& operator=(const GetFreshAddressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetFreshAddressResponse(GetFreshAddressResponse&& from) noexcept
    : GetFreshAddressResponse() {
    *this = ::std::move(from);
  }

  inline GetFreshAddressResponse& operator=(GetFreshAddressResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetFreshAddressResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetFreshAddressResponse* internal_default_instance() {
    return reinterpret_cast<const GetFreshAddressResponse*>(
               &_GetFreshAddressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GetFreshAddressResponse* other);
  friend void swap(GetFreshAddressResponse& a, GetFreshAddressResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetFreshAddressResponse* New() const final {
    return CreateMaybeMessage<GetFreshAddressResponse>(nullptr);
  }

  GetFreshAddressResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetFreshAddressResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetFreshAddressResponse& from);
  void MergeFrom(const GetFreshAddressResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFreshAddressResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetFreshAddressResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class BitcoinRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.BitcoinRequest) */ {
 public:
  BitcoinRequest();
  virtual ~BitcoinRequest();

  BitcoinRequest(const BitcoinRequest& from);

  inline BitcoinRequest& operator=(const BitcoinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BitcoinRequest(BitcoinRequest&& from) noexcept
    : BitcoinRequest() {
    *this = ::std::move(from);
  }

  inline BitcoinRequest& operator=(BitcoinRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BitcoinRequest& default_instance();

  enum RequestCase {
    kSyncAccount = 1,
    kGetBalance = 2,
    kGetOperations = 3,
    kGetLastBlock = 4,
    kGetFreshAddress = 5,
    REQUEST_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BitcoinRequest* internal_default_instance() {
    return reinterpret_cast<const BitcoinRequest*>(
               &_BitcoinRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(BitcoinRequest* other);
  friend void swap(BitcoinRequest& a, BitcoinRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BitcoinRequest* New() const final {
    return CreateMaybeMessage<BitcoinRequest>(nullptr);
  }

  BitcoinRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BitcoinRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BitcoinRequest& from);
  void MergeFrom(const BitcoinRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitcoinRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.core.message.bitcoin.SyncAccountRequest sync_account = 1;
  bool has_sync_account() const;
  void clear_sync_account();
  static const int kSyncAccountFieldNumber = 1;
  const ::ledger::core::message::bitcoin::SyncAccountRequest& sync_account() const;
  ::ledger::core::message::bitcoin::SyncAccountRequest* release_sync_account();
  ::ledger::core::message::bitcoin::SyncAccountRequest* mutable_sync_account();
  void set_allocated_sync_account(::ledger::core::message::bitcoin::SyncAccountRequest* sync_account);

  // .ledger.core.message.bitcoin.GetBalanceRequest get_balance = 2;
  bool has_get_balance() const;
  void clear_get_balance();
  static const int kGetBalanceFieldNumber = 2;
  const ::ledger::core::message::bitcoin::GetBalanceRequest& get_balance() const;
  ::ledger::core::message::bitcoin::GetBalanceRequest* release_get_balance();
  ::ledger::core::message::bitcoin::GetBalanceRequest* mutable_get_balance();
  void set_allocated_get_balance(::ledger::core::message::bitcoin::GetBalanceRequest* get_balance);

  // .ledger.core.message.bitcoin.GetOperationsRequest get_operations = 3;
  bool has_get_operations() const;
  void clear_get_operations();
  static const int kGetOperationsFieldNumber = 3;
  const ::ledger::core::message::bitcoin::GetOperationsRequest& get_operations() const;
  ::ledger::core::message::bitcoin::GetOperationsRequest* release_get_operations();
  ::ledger::core::message::bitcoin::GetOperationsRequest* mutable_get_operations();
  void set_allocated_get_operations(::ledger::core::message::bitcoin::GetOperationsRequest* get_operations);

  // .ledger.core.message.bitcoin.GetLastBlockRequest get_last_block = 4;
  bool has_get_last_block() const;
  void clear_get_last_block();
  static const int kGetLastBlockFieldNumber = 4;
  const ::ledger::core::message::bitcoin::GetLastBlockRequest& get_last_block() const;
  ::ledger::core::message::bitcoin::GetLastBlockRequest* release_get_last_block();
  ::ledger::core::message::bitcoin::GetLastBlockRequest* mutable_get_last_block();
  void set_allocated_get_last_block(::ledger::core::message::bitcoin::GetLastBlockRequest* get_last_block);

  // .ledger.core.message.bitcoin.GetFreshAddressRequest get_fresh_address = 5;
  bool has_get_fresh_address() const;
  void clear_get_fresh_address();
  static const int kGetFreshAddressFieldNumber = 5;
  const ::ledger::core::message::bitcoin::GetFreshAddressRequest& get_fresh_address() const;
  ::ledger::core::message::bitcoin::GetFreshAddressRequest* release_get_fresh_address();
  ::ledger::core::message::bitcoin::GetFreshAddressRequest* mutable_get_fresh_address();
  void set_allocated_get_fresh_address(::ledger::core::message::bitcoin::GetFreshAddressRequest* get_fresh_address);

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.BitcoinRequest)
 private:
  class HasBitSetters;
  void set_has_sync_account();
  void set_has_get_balance();
  void set_has_get_operations();
  void set_has_get_last_block();
  void set_has_get_fresh_address();

  inline bool has_request() const;
  inline void clear_has_request();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union RequestUnion {
    RequestUnion() {}
    ::ledger::core::message::bitcoin::SyncAccountRequest* sync_account_;
    ::ledger::core::message::bitcoin::GetBalanceRequest* get_balance_;
    ::ledger::core::message::bitcoin::GetOperationsRequest* get_operations_;
    ::ledger::core::message::bitcoin::GetLastBlockRequest* get_last_block_;
    ::ledger::core::message::bitcoin::GetFreshAddressRequest* get_fresh_address_;
  } request_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LedgerExplorerConfig

// uint32 version = 1;
inline void LedgerExplorerConfig::clear_version() {
  version_ = 0u;
}
inline ::google::protobuf::uint32 LedgerExplorerConfig::version() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.LedgerExplorerConfig.version)
  return version_;
}
inline void LedgerExplorerConfig::set_version(::google::protobuf::uint32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.LedgerExplorerConfig.version)
}

// string endpoint = 2;
inline void LedgerExplorerConfig::clear_endpoint() {
  endpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerExplorerConfig::endpoint() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.LedgerExplorerConfig.endpoint)
  return endpoint_.GetNoArena();
}
inline void LedgerExplorerConfig::set_endpoint(const ::std::string& value) {
  
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.LedgerExplorerConfig.endpoint)
}
#if LANG_CXX11
inline void LedgerExplorerConfig::set_endpoint(::std::string&& value) {
  
  endpoint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.core.message.bitcoin.LedgerExplorerConfig.endpoint)
}
#endif
inline void LedgerExplorerConfig::set_endpoint(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.core.message.bitcoin.LedgerExplorerConfig.endpoint)
}
inline void LedgerExplorerConfig::set_endpoint(const char* value, size_t size) {
  
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.core.message.bitcoin.LedgerExplorerConfig.endpoint)
}
inline ::std::string* LedgerExplorerConfig::mutable_endpoint() {
  
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.LedgerExplorerConfig.endpoint)
  return endpoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerExplorerConfig::release_endpoint() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.LedgerExplorerConfig.endpoint)
  
  return endpoint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerExplorerConfig::set_allocated_endpoint(::std::string* endpoint) {
  if (endpoint != nullptr) {
    
  } else {
    
  }
  endpoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), endpoint);
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.LedgerExplorerConfig.endpoint)
}

// uint32 port = 3;
inline void LedgerExplorerConfig::clear_port() {
  port_ = 0u;
}
inline ::google::protobuf::uint32 LedgerExplorerConfig::port() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.LedgerExplorerConfig.port)
  return port_;
}
inline void LedgerExplorerConfig::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.LedgerExplorerConfig.port)
}

// -------------------------------------------------------------------

// SyncAccountRequest

// .ledger.core.message.bitcoin.AccountID account_id = 1;
inline bool SyncAccountRequest::has_account_id() const {
  return this != internal_default_instance() && account_id_ != nullptr;
}
inline const ::ledger::core::message::bitcoin::AccountID& SyncAccountRequest::account_id() const {
  const ::ledger::core::message::bitcoin::AccountID* p = account_id_;
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.SyncAccountRequest.account_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::ledger::core::message::bitcoin::AccountID*>(
      &::ledger::core::message::bitcoin::_AccountID_default_instance_);
}
inline ::ledger::core::message::bitcoin::AccountID* SyncAccountRequest::release_account_id() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.SyncAccountRequest.account_id)
  
  ::ledger::core::message::bitcoin::AccountID* temp = account_id_;
  account_id_ = nullptr;
  return temp;
}
inline ::ledger::core::message::bitcoin::AccountID* SyncAccountRequest::mutable_account_id() {
  
  if (account_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ledger::core::message::bitcoin::AccountID>(GetArenaNoVirtual());
    account_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.SyncAccountRequest.account_id)
  return account_id_;
}
inline void SyncAccountRequest::set_allocated_account_id(::ledger::core::message::bitcoin::AccountID* account_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(account_id_);
  }
  if (account_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account_id, submessage_arena);
    }
    
  } else {
    
  }
  account_id_ = account_id;
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.SyncAccountRequest.account_id)
}

// .ledger.core.message.bitcoin.LedgerExplorerConfig explorer = 2;
inline bool SyncAccountRequest::has_explorer() const {
  return this != internal_default_instance() && explorer_ != nullptr;
}
inline void SyncAccountRequest::clear_explorer() {
  if (GetArenaNoVirtual() == nullptr && explorer_ != nullptr) {
    delete explorer_;
  }
  explorer_ = nullptr;
}
inline const ::ledger::core::message::bitcoin::LedgerExplorerConfig& SyncAccountRequest::explorer() const {
  const ::ledger::core::message::bitcoin::LedgerExplorerConfig* p = explorer_;
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.SyncAccountRequest.explorer)
  return p != nullptr ? *p : *reinterpret_cast<const ::ledger::core::message::bitcoin::LedgerExplorerConfig*>(
      &::ledger::core::message::bitcoin::_LedgerExplorerConfig_default_instance_);
}
inline ::ledger::core::message::bitcoin::LedgerExplorerConfig* SyncAccountRequest::release_explorer() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.SyncAccountRequest.explorer)
  
  ::ledger::core::message::bitcoin::LedgerExplorerConfig* temp = explorer_;
  explorer_ = nullptr;
  return temp;
}
inline ::ledger::core::message::bitcoin::LedgerExplorerConfig* SyncAccountRequest::mutable_explorer() {
  
  if (explorer_ == nullptr) {
    auto* p = CreateMaybeMessage<::ledger::core::message::bitcoin::LedgerExplorerConfig>(GetArenaNoVirtual());
    explorer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.SyncAccountRequest.explorer)
  return explorer_;
}
inline void SyncAccountRequest::set_allocated_explorer(::ledger::core::message::bitcoin::LedgerExplorerConfig* explorer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete explorer_;
  }
  if (explorer) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      explorer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, explorer, submessage_arena);
    }
    
  } else {
    
  }
  explorer_ = explorer;
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.SyncAccountRequest.explorer)
}

// -------------------------------------------------------------------

// SyncAccountResponse

// bool new_acc = 1;
inline void SyncAccountResponse::clear_new_acc() {
  new_acc_ = false;
}
inline bool SyncAccountResponse::new_acc() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.SyncAccountResponse.new_acc)
  return new_acc_;
}
inline void SyncAccountResponse::set_new_acc(bool value) {
  
  new_acc_ = value;
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.SyncAccountResponse.new_acc)
}

// -------------------------------------------------------------------

// GetBalanceRequest

// .ledger.core.message.bitcoin.AccountID account_id = 1;
inline bool GetBalanceRequest::has_account_id() const {
  return this != internal_default_instance() && account_id_ != nullptr;
}
inline const ::ledger::core::message::bitcoin::AccountID& GetBalanceRequest::account_id() const {
  const ::ledger::core::message::bitcoin::AccountID* p = account_id_;
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetBalanceRequest.account_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::ledger::core::message::bitcoin::AccountID*>(
      &::ledger::core::message::bitcoin::_AccountID_default_instance_);
}
inline ::ledger::core::message::bitcoin::AccountID* GetBalanceRequest::release_account_id() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.GetBalanceRequest.account_id)
  
  ::ledger::core::message::bitcoin::AccountID* temp = account_id_;
  account_id_ = nullptr;
  return temp;
}
inline ::ledger::core::message::bitcoin::AccountID* GetBalanceRequest::mutable_account_id() {
  
  if (account_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ledger::core::message::bitcoin::AccountID>(GetArenaNoVirtual());
    account_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetBalanceRequest.account_id)
  return account_id_;
}
inline void GetBalanceRequest::set_allocated_account_id(::ledger::core::message::bitcoin::AccountID* account_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(account_id_);
  }
  if (account_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account_id, submessage_arena);
    }
    
  } else {
    
  }
  account_id_ = account_id;
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.GetBalanceRequest.account_id)
}

// -------------------------------------------------------------------

// GetBalanceResponse

// .ledger.core.message.common.Amount amount = 1;
inline bool GetBalanceResponse::has_amount() const {
  return this != internal_default_instance() && amount_ != nullptr;
}
inline const ::ledger::core::message::common::Amount& GetBalanceResponse::amount() const {
  const ::ledger::core::message::common::Amount* p = amount_;
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetBalanceResponse.amount)
  return p != nullptr ? *p : *reinterpret_cast<const ::ledger::core::message::common::Amount*>(
      &::ledger::core::message::common::_Amount_default_instance_);
}
inline ::ledger::core::message::common::Amount* GetBalanceResponse::release_amount() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.GetBalanceResponse.amount)
  
  ::ledger::core::message::common::Amount* temp = amount_;
  amount_ = nullptr;
  return temp;
}
inline ::ledger::core::message::common::Amount* GetBalanceResponse::mutable_amount() {
  
  if (amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::ledger::core::message::common::Amount>(GetArenaNoVirtual());
    amount_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetBalanceResponse.amount)
  return amount_;
}
inline void GetBalanceResponse::set_allocated_amount(::ledger::core::message::common::Amount* amount) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(amount_);
  }
  if (amount) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      amount = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    
  } else {
    
  }
  amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.GetBalanceResponse.amount)
}

// -------------------------------------------------------------------

// GetOperationsRequest

// .ledger.core.message.bitcoin.AccountID account_id = 1;
inline bool GetOperationsRequest::has_account_id() const {
  return this != internal_default_instance() && account_id_ != nullptr;
}
inline const ::ledger::core::message::bitcoin::AccountID& GetOperationsRequest::account_id() const {
  const ::ledger::core::message::bitcoin::AccountID* p = account_id_;
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetOperationsRequest.account_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::ledger::core::message::bitcoin::AccountID*>(
      &::ledger::core::message::bitcoin::_AccountID_default_instance_);
}
inline ::ledger::core::message::bitcoin::AccountID* GetOperationsRequest::release_account_id() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.GetOperationsRequest.account_id)
  
  ::ledger::core::message::bitcoin::AccountID* temp = account_id_;
  account_id_ = nullptr;
  return temp;
}
inline ::ledger::core::message::bitcoin::AccountID* GetOperationsRequest::mutable_account_id() {
  
  if (account_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ledger::core::message::bitcoin::AccountID>(GetArenaNoVirtual());
    account_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetOperationsRequest.account_id)
  return account_id_;
}
inline void GetOperationsRequest::set_allocated_account_id(::ledger::core::message::bitcoin::AccountID* account_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(account_id_);
  }
  if (account_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account_id, submessage_arena);
    }
    
  } else {
    
  }
  account_id_ = account_id;
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.GetOperationsRequest.account_id)
}

// -------------------------------------------------------------------

// GetOperationsResponse

// repeated .ledger.core.message.bitcoin.Operation operations = 1;
inline int GetOperationsResponse::operations_size() const {
  return operations_.size();
}
inline ::ledger::core::message::bitcoin::Operation* GetOperationsResponse::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetOperationsResponse.operations)
  return operations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Operation >*
GetOperationsResponse::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:ledger.core.message.bitcoin.GetOperationsResponse.operations)
  return &operations_;
}
inline const ::ledger::core::message::bitcoin::Operation& GetOperationsResponse::operations(int index) const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetOperationsResponse.operations)
  return operations_.Get(index);
}
inline ::ledger::core::message::bitcoin::Operation* GetOperationsResponse::add_operations() {
  // @@protoc_insertion_point(field_add:ledger.core.message.bitcoin.GetOperationsResponse.operations)
  return operations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Operation >&
GetOperationsResponse::operations() const {
  // @@protoc_insertion_point(field_list:ledger.core.message.bitcoin.GetOperationsResponse.operations)
  return operations_;
}

// -------------------------------------------------------------------

// GetLastBlockRequest

// .ledger.core.message.bitcoin.AccountID account_id = 1;
inline bool GetLastBlockRequest::has_account_id() const {
  return this != internal_default_instance() && account_id_ != nullptr;
}
inline const ::ledger::core::message::bitcoin::AccountID& GetLastBlockRequest::account_id() const {
  const ::ledger::core::message::bitcoin::AccountID* p = account_id_;
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetLastBlockRequest.account_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::ledger::core::message::bitcoin::AccountID*>(
      &::ledger::core::message::bitcoin::_AccountID_default_instance_);
}
inline ::ledger::core::message::bitcoin::AccountID* GetLastBlockRequest::release_account_id() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.GetLastBlockRequest.account_id)
  
  ::ledger::core::message::bitcoin::AccountID* temp = account_id_;
  account_id_ = nullptr;
  return temp;
}
inline ::ledger::core::message::bitcoin::AccountID* GetLastBlockRequest::mutable_account_id() {
  
  if (account_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ledger::core::message::bitcoin::AccountID>(GetArenaNoVirtual());
    account_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetLastBlockRequest.account_id)
  return account_id_;
}
inline void GetLastBlockRequest::set_allocated_account_id(::ledger::core::message::bitcoin::AccountID* account_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(account_id_);
  }
  if (account_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account_id, submessage_arena);
    }
    
  } else {
    
  }
  account_id_ = account_id;
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.GetLastBlockRequest.account_id)
}

// -------------------------------------------------------------------

// GetLastBlockResponse

// .ledger.core.message.common.Block last_block = 1;
inline bool GetLastBlockResponse::has_last_block() const {
  return this != internal_default_instance() && last_block_ != nullptr;
}
inline const ::ledger::core::message::common::Block& GetLastBlockResponse::last_block() const {
  const ::ledger::core::message::common::Block* p = last_block_;
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetLastBlockResponse.last_block)
  return p != nullptr ? *p : *reinterpret_cast<const ::ledger::core::message::common::Block*>(
      &::ledger::core::message::common::_Block_default_instance_);
}
inline ::ledger::core::message::common::Block* GetLastBlockResponse::release_last_block() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.GetLastBlockResponse.last_block)
  
  ::ledger::core::message::common::Block* temp = last_block_;
  last_block_ = nullptr;
  return temp;
}
inline ::ledger::core::message::common::Block* GetLastBlockResponse::mutable_last_block() {
  
  if (last_block_ == nullptr) {
    auto* p = CreateMaybeMessage<::ledger::core::message::common::Block>(GetArenaNoVirtual());
    last_block_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetLastBlockResponse.last_block)
  return last_block_;
}
inline void GetLastBlockResponse::set_allocated_last_block(::ledger::core::message::common::Block* last_block) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(last_block_);
  }
  if (last_block) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      last_block = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, last_block, submessage_arena);
    }
    
  } else {
    
  }
  last_block_ = last_block;
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.GetLastBlockResponse.last_block)
}

// -------------------------------------------------------------------

// GetFreshAddressRequest

// .ledger.core.message.bitcoin.AccountID account_id = 1;
inline bool GetFreshAddressRequest::has_account_id() const {
  return this != internal_default_instance() && account_id_ != nullptr;
}
inline const ::ledger::core::message::bitcoin::AccountID& GetFreshAddressRequest::account_id() const {
  const ::ledger::core::message::bitcoin::AccountID* p = account_id_;
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetFreshAddressRequest.account_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::ledger::core::message::bitcoin::AccountID*>(
      &::ledger::core::message::bitcoin::_AccountID_default_instance_);
}
inline ::ledger::core::message::bitcoin::AccountID* GetFreshAddressRequest::release_account_id() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.GetFreshAddressRequest.account_id)
  
  ::ledger::core::message::bitcoin::AccountID* temp = account_id_;
  account_id_ = nullptr;
  return temp;
}
inline ::ledger::core::message::bitcoin::AccountID* GetFreshAddressRequest::mutable_account_id() {
  
  if (account_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ledger::core::message::bitcoin::AccountID>(GetArenaNoVirtual());
    account_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetFreshAddressRequest.account_id)
  return account_id_;
}
inline void GetFreshAddressRequest::set_allocated_account_id(::ledger::core::message::bitcoin::AccountID* account_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(account_id_);
  }
  if (account_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account_id, submessage_arena);
    }
    
  } else {
    
  }
  account_id_ = account_id;
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.GetFreshAddressRequest.account_id)
}

// -------------------------------------------------------------------

// GetFreshAddressResponse

// string address = 1;
inline void GetFreshAddressResponse::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetFreshAddressResponse::address() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetFreshAddressResponse.address)
  return address_.GetNoArena();
}
inline void GetFreshAddressResponse::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.GetFreshAddressResponse.address)
}
#if LANG_CXX11
inline void GetFreshAddressResponse::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.core.message.bitcoin.GetFreshAddressResponse.address)
}
#endif
inline void GetFreshAddressResponse::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.core.message.bitcoin.GetFreshAddressResponse.address)
}
inline void GetFreshAddressResponse::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.core.message.bitcoin.GetFreshAddressResponse.address)
}
inline ::std::string* GetFreshAddressResponse::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetFreshAddressResponse.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetFreshAddressResponse::release_address() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.GetFreshAddressResponse.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetFreshAddressResponse::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.GetFreshAddressResponse.address)
}

// string path = 2;
inline void GetFreshAddressResponse::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetFreshAddressResponse::path() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetFreshAddressResponse.path)
  return path_.GetNoArena();
}
inline void GetFreshAddressResponse::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.GetFreshAddressResponse.path)
}
#if LANG_CXX11
inline void GetFreshAddressResponse::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.core.message.bitcoin.GetFreshAddressResponse.path)
}
#endif
inline void GetFreshAddressResponse::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.core.message.bitcoin.GetFreshAddressResponse.path)
}
inline void GetFreshAddressResponse::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.core.message.bitcoin.GetFreshAddressResponse.path)
}
inline ::std::string* GetFreshAddressResponse::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetFreshAddressResponse.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetFreshAddressResponse::release_path() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.GetFreshAddressResponse.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetFreshAddressResponse::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.GetFreshAddressResponse.path)
}

// -------------------------------------------------------------------

// BitcoinRequest

// .ledger.core.message.bitcoin.SyncAccountRequest sync_account = 1;
inline bool BitcoinRequest::has_sync_account() const {
  return request_case() == kSyncAccount;
}
inline void BitcoinRequest::set_has_sync_account() {
  _oneof_case_[0] = kSyncAccount;
}
inline void BitcoinRequest::clear_sync_account() {
  if (has_sync_account()) {
    delete request_.sync_account_;
    clear_has_request();
  }
}
inline ::ledger::core::message::bitcoin::SyncAccountRequest* BitcoinRequest::release_sync_account() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.BitcoinRequest.sync_account)
  if (has_sync_account()) {
    clear_has_request();
      ::ledger::core::message::bitcoin::SyncAccountRequest* temp = request_.sync_account_;
    request_.sync_account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ledger::core::message::bitcoin::SyncAccountRequest& BitcoinRequest::sync_account() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.BitcoinRequest.sync_account)
  return has_sync_account()
      ? *request_.sync_account_
      : *reinterpret_cast< ::ledger::core::message::bitcoin::SyncAccountRequest*>(&::ledger::core::message::bitcoin::_SyncAccountRequest_default_instance_);
}
inline ::ledger::core::message::bitcoin::SyncAccountRequest* BitcoinRequest::mutable_sync_account() {
  if (!has_sync_account()) {
    clear_request();
    set_has_sync_account();
    request_.sync_account_ = CreateMaybeMessage< ::ledger::core::message::bitcoin::SyncAccountRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.BitcoinRequest.sync_account)
  return request_.sync_account_;
}

// .ledger.core.message.bitcoin.GetBalanceRequest get_balance = 2;
inline bool BitcoinRequest::has_get_balance() const {
  return request_case() == kGetBalance;
}
inline void BitcoinRequest::set_has_get_balance() {
  _oneof_case_[0] = kGetBalance;
}
inline void BitcoinRequest::clear_get_balance() {
  if (has_get_balance()) {
    delete request_.get_balance_;
    clear_has_request();
  }
}
inline ::ledger::core::message::bitcoin::GetBalanceRequest* BitcoinRequest::release_get_balance() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.BitcoinRequest.get_balance)
  if (has_get_balance()) {
    clear_has_request();
      ::ledger::core::message::bitcoin::GetBalanceRequest* temp = request_.get_balance_;
    request_.get_balance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ledger::core::message::bitcoin::GetBalanceRequest& BitcoinRequest::get_balance() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.BitcoinRequest.get_balance)
  return has_get_balance()
      ? *request_.get_balance_
      : *reinterpret_cast< ::ledger::core::message::bitcoin::GetBalanceRequest*>(&::ledger::core::message::bitcoin::_GetBalanceRequest_default_instance_);
}
inline ::ledger::core::message::bitcoin::GetBalanceRequest* BitcoinRequest::mutable_get_balance() {
  if (!has_get_balance()) {
    clear_request();
    set_has_get_balance();
    request_.get_balance_ = CreateMaybeMessage< ::ledger::core::message::bitcoin::GetBalanceRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.BitcoinRequest.get_balance)
  return request_.get_balance_;
}

// .ledger.core.message.bitcoin.GetOperationsRequest get_operations = 3;
inline bool BitcoinRequest::has_get_operations() const {
  return request_case() == kGetOperations;
}
inline void BitcoinRequest::set_has_get_operations() {
  _oneof_case_[0] = kGetOperations;
}
inline void BitcoinRequest::clear_get_operations() {
  if (has_get_operations()) {
    delete request_.get_operations_;
    clear_has_request();
  }
}
inline ::ledger::core::message::bitcoin::GetOperationsRequest* BitcoinRequest::release_get_operations() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.BitcoinRequest.get_operations)
  if (has_get_operations()) {
    clear_has_request();
      ::ledger::core::message::bitcoin::GetOperationsRequest* temp = request_.get_operations_;
    request_.get_operations_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ledger::core::message::bitcoin::GetOperationsRequest& BitcoinRequest::get_operations() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.BitcoinRequest.get_operations)
  return has_get_operations()
      ? *request_.get_operations_
      : *reinterpret_cast< ::ledger::core::message::bitcoin::GetOperationsRequest*>(&::ledger::core::message::bitcoin::_GetOperationsRequest_default_instance_);
}
inline ::ledger::core::message::bitcoin::GetOperationsRequest* BitcoinRequest::mutable_get_operations() {
  if (!has_get_operations()) {
    clear_request();
    set_has_get_operations();
    request_.get_operations_ = CreateMaybeMessage< ::ledger::core::message::bitcoin::GetOperationsRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.BitcoinRequest.get_operations)
  return request_.get_operations_;
}

// .ledger.core.message.bitcoin.GetLastBlockRequest get_last_block = 4;
inline bool BitcoinRequest::has_get_last_block() const {
  return request_case() == kGetLastBlock;
}
inline void BitcoinRequest::set_has_get_last_block() {
  _oneof_case_[0] = kGetLastBlock;
}
inline void BitcoinRequest::clear_get_last_block() {
  if (has_get_last_block()) {
    delete request_.get_last_block_;
    clear_has_request();
  }
}
inline ::ledger::core::message::bitcoin::GetLastBlockRequest* BitcoinRequest::release_get_last_block() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.BitcoinRequest.get_last_block)
  if (has_get_last_block()) {
    clear_has_request();
      ::ledger::core::message::bitcoin::GetLastBlockRequest* temp = request_.get_last_block_;
    request_.get_last_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ledger::core::message::bitcoin::GetLastBlockRequest& BitcoinRequest::get_last_block() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.BitcoinRequest.get_last_block)
  return has_get_last_block()
      ? *request_.get_last_block_
      : *reinterpret_cast< ::ledger::core::message::bitcoin::GetLastBlockRequest*>(&::ledger::core::message::bitcoin::_GetLastBlockRequest_default_instance_);
}
inline ::ledger::core::message::bitcoin::GetLastBlockRequest* BitcoinRequest::mutable_get_last_block() {
  if (!has_get_last_block()) {
    clear_request();
    set_has_get_last_block();
    request_.get_last_block_ = CreateMaybeMessage< ::ledger::core::message::bitcoin::GetLastBlockRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.BitcoinRequest.get_last_block)
  return request_.get_last_block_;
}

// .ledger.core.message.bitcoin.GetFreshAddressRequest get_fresh_address = 5;
inline bool BitcoinRequest::has_get_fresh_address() const {
  return request_case() == kGetFreshAddress;
}
inline void BitcoinRequest::set_has_get_fresh_address() {
  _oneof_case_[0] = kGetFreshAddress;
}
inline void BitcoinRequest::clear_get_fresh_address() {
  if (has_get_fresh_address()) {
    delete request_.get_fresh_address_;
    clear_has_request();
  }
}
inline ::ledger::core::message::bitcoin::GetFreshAddressRequest* BitcoinRequest::release_get_fresh_address() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.BitcoinRequest.get_fresh_address)
  if (has_get_fresh_address()) {
    clear_has_request();
      ::ledger::core::message::bitcoin::GetFreshAddressRequest* temp = request_.get_fresh_address_;
    request_.get_fresh_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ledger::core::message::bitcoin::GetFreshAddressRequest& BitcoinRequest::get_fresh_address() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.BitcoinRequest.get_fresh_address)
  return has_get_fresh_address()
      ? *request_.get_fresh_address_
      : *reinterpret_cast< ::ledger::core::message::bitcoin::GetFreshAddressRequest*>(&::ledger::core::message::bitcoin::_GetFreshAddressRequest_default_instance_);
}
inline ::ledger::core::message::bitcoin::GetFreshAddressRequest* BitcoinRequest::mutable_get_fresh_address() {
  if (!has_get_fresh_address()) {
    clear_request();
    set_has_get_fresh_address();
    request_.get_fresh_address_ = CreateMaybeMessage< ::ledger::core::message::bitcoin::GetFreshAddressRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.BitcoinRequest.get_fresh_address)
  return request_.get_fresh_address_;
}

inline bool BitcoinRequest::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void BitcoinRequest::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline BitcoinRequest::RequestCase BitcoinRequest::request_case() const {
  return BitcoinRequest::RequestCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bitcoin
}  // namespace message
}  // namespace core
}  // namespace ledger

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_bitcoin_2fcommands_2eproto
